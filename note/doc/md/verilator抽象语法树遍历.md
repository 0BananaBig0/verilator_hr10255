# verilator 抽象语法树遍历方式

verilator 作为EDA综合分析工具，其自身本就支持将 verilog 格式的硬件电路设计转化为例如 C 语言的仿真型电路设计，亦或者
是 xml 格式的描述型电路设计；其之所以可以支持从 verilog 单一的输入格式到例如C或者xml的多格式输出，很大程度上取决于
verilator在设计AST时将其数据结构的设计以及其访问相隔离。

在软件设计领域，一个完整的程序等价于数据结构和算法，数据结构可以看做是程序的静态部分，而算法则可以看做是程序的动态部分；
相对与算法，数据结构的稳定性会更强，即设计好的数据结构在很长的一段时间内都不会发生太大的变化，这时候通常可以使用设计模式
中的访问者模式进行设计，verilator 正是使用访问者模式进行 AST 的设计。

在 《设计模式》 一书中，作者对访问者模式的评价是这样的,“大多情况下，你不需要使用访问者模式，但是一旦需要使用它时，那就真的需要使用了。”，
虽然承认着访问者模式存在一定的局限性，但是也凸显出了访问者模式在关键情况下的重要性；对于访问者模式的经典之作，C++的STL是当之无愧的典范，
STL将其分之为容器，迭代器以及算法；若将verilator使用访问者容器实现对抽象语法树的遍历按照STL的说法来解释的话，无疑AstNode指的就是容器，
而AstNVisitor则意味着算法，则如果要想将容器与算法搭建起来，则迭代器无疑是至关重要的桥梁。

verilator 实现类似于迭代器的桥梁的方式比较巧妙;AstNode 中具有一个纯虚的方法 virtual void accept(AstNVisitor& v)，而在 AstNVisitor
中则实现了 AstNode 以及其衍生类的 visit 方法，例如 virtual void visit(AstBreak* nodep);同时在 AstNVisitor 还提供了基础的访问方式，
在这些访问方式中调用到了 AstNode 的 accept 方法，而在 accept 方法中又返回过调用到了 AstNVisitor 中的 visit 方法；从代码的角度来看
visit 方法就是一个钩子函数，在钩子函数中重写想要遍历数据的不同形式就可以得到不同的算法，而重写 visit 钩子函数的方法就是继承 AstNVisitor
并重写此方法；verilator的这个设计是完全符合访问者模式的理念的，因为在对钩子函数重写的过程中，也就是新增不同的算法的同时，并不会对原有的数据
结构做任何的修改。
